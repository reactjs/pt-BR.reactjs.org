---
title: "React v16.3.0: Novos ciclos de vida e API de contexto"
author: [bvaughn]
---

Há alguns dias, [escrevemos uma postagem sobre as próximas mudanças em nossos métodos de ciclo de vida herdados](/blog/2018/03/27/update-on-async-rendering.html), incluindo estratégias de migração gradual. No React 16.3.0, estamos adicionando alguns novos métodos de ciclo de vida para ajudar nessa migração. Também estamos introduzindo novas APIs para longas características solicitadas: uma API de contexto oficial, uma API de encaminhamento de referência e uma API de referência ergonômica.

Leia para saber mais sobre o lançamento.

## API de Contexto Oficial {#official-context-api}

Por muitos anos, o React ofereceu uma API experimental para contexto. Embora fosse uma ferramenta poderosa, seu uso foi desencorajado por causa de problemas inerentes na API, e porque sempre pretendíamos substituir a API experimental por uma melhor.

A versão 16.3 introduz uma nova API de contexto que é mais eficiente e suporta tanto verificação de tipo estático quanto atualizações profundas.

> **Nota**
>
> A antiga API de contexto continuará funcionando para todas as versões do React 16.x, assim você terá tempo para migrar.

Aqui está um exemplo ilustrando como você pode introduzir um “tema” usando a nova API de contexto:
`embed:16-3-release-blog-post/context-example.js`

[Saiba mais sobre a nova API de contexto aqui.](/docs/context.html)

## API `createRef` {#createref-api}

Anteriormente, o React fornecia duas maneiras de gerenciar refs: a API de string ref e a API de callback. Embora a API de string ref ter sido a mais conveniente das duas, ela tinha [várias desvantagens](https://github.com/facebook/react/issues/1373) e assim nossa recomendação oficial era usar o formulário de callback.

A versão 16.3 adiciona uma nova opção para gerenciar refs que oferecem o conforto de uma string ref sem nenhuma das desvantagens:
`embed:16-3-release-blog-post/create-ref-example.js`

> **Nota:**
>
> As refs de callbacks continuarão sendo suportadas, além da nova API `createRef`.
>
> Você não precisa substituir as callback refs em seus componentes. Elas são um pouco mais flexíveis, portanto, elas permanecerão como um recurso avançado.

[Saiba mais sobre a nova API `createRef` aqui.](/docs/refs-and-the-dom.html)

## API `forwardRef` {#forwardref-api}

Geralmente, os componentes React são declarativos, mas às vezes é necessário o acesso imperativo às instâncias do componente e aos nós DOM subjacentes. Isso é comum em casos de uso, como gerenciamento de foco, seleção ou animações. O React fornece [refs](/docs/refs-and-the-dom.html) como uma forma de resolver este problema. No entanto, o encapsulamento de componentes apresenta alguns desafios com as refs.

Por exemplo, se você trocar um `<button>` por um componente `<FancyButton>`, o atributo `ref` nele começará apontando para o componente wrapper em vez do nó DOM (e seria `null` para componentes funcionais). Embora isso seja desejável para componentes de "nível de aplicação" como `FeedStory` ou `Comment` que precisam ser encapsulados, isso pode ser irritante para componentes "folha" como `FancyButton` ou `MyTextInput` que são tipicamente usados como seus homólogos DOM, e podem precisar expor seus nós DOM.

O encaminhamento de referência é um novo recurso de inclusão que permite que alguns componentes `ref` sejam recebidos, e passem para baixo (em outras palavras, "encaminhá-lo") para um filho. No exemplo abaixo, `FancyButton` encaminha seu ref para um DOM `button` que renderiza:

`embed:16-3-release-blog-post/fancy-button-example.js`

Dessa forma, os componentes que usam `FancyButton` podem obter uma ref ao nó do DOM do `button` subjacente e acessá-lo se necessário—assim como se usassem um `button` DOM diretamente.

O encaminhamento de ref não está limitado para componentes de "folha" que rederizam nós do DOM. Se você escreve [componente de alta-ordem](/docs/higher-order-components.html), recomendamos o uso do encaminhamento de referência para passar automaticamente as ref para as instâncias do componente de classe wrapper.

[Saiba mais sobre a API forwardRef aqui.](/docs/forwarding-refs.html)

## Mudanças no Ciclo de Vida do Componente {#component-lifecycle-changes}

A API de componente de classe do React existe há anos com poucas mudanças. No entanto, como nós adicionamos suporte a recursos mais avançados (tal como [limite de erros](/docs/react-component.html#componentdidcatch) e o próximo [modo de renderização assíncrona](/blog/2018/03/01/sneak-peek-beyond-react-16.html)) nós estendemos este modelo de maneiras que não foram originalmente pretendidas.

Por exemplo, com a API atual, é muito fácil bloquear a renderização inicial com lógica não essencial. Em parte, isso ocorre porque há muitas maneiras de realizar uma determinada tarefa, e pode não ser claro qual é a melhor. Observamos que o comportamento de interrupção do tratamento de erros geralmente não é levado em consideração e pode resultar em vazamentos de memória (algo que também afetará o próximo modo de renderização assíncrona). A API do componente de classe atual também complica outros esforços, como o nosso trabalho em [prototipar um compilador React](https://twitter.com/trueadm/status/944908776896978946).

Muitos desses problemas são exacerbados por um subconjunto dos ciclos de vida dos componentes (`componentWillMount`, `componentWillReceiveProps`, e `componentWillUpdate`). Esses também são os ciclos de vida que mais causam confusão na comunidade React. Por essas razões, vamos depreciar esses métodos em favor de alternativas melhores.

Reconhecemos que essa alteração afetará muitos componentes existentes. Por isso, o caminho de migração será o mais gradual possível e fornecerá escotilhas de escape. (No Facebook, mantemos mais de 50.000 componentes React. Também dependemos de um ciclo de lançamento gradual!)

> **Nota:**
>
> Os avisos de deprecação serão ativados com uma versão 16.x futura, **mas os ciclos de vida herdados continuarão funcionando até a versão 17**.
>
> Mesmo na versão 17, ainda será possível usá-los, mas eles terão um prefixo "UNSAFE_" para indicar que podem causar problemas. Nós também preparamos um [script automatizado para renomeá-los](https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles) no código existente.

Além de deprecar ciclos de vida inseguros, também estamos adicionando alguns novos ciclos de vida:
* [`getDerivedStateFromProps`](/docs/react-component.html#static-getderivedstatefromprops) está sendo adicionado como uma alternativa mais segura ao antigo `componentWillReceiveProps`. (Note que [na maioria dos casos você não precisa de nenhum deles](/blog/2018/06/07/you-probably-dont-need-derived-state.html).)
* [`getSnapshotBeforeUpdate`](/docs/react-component.html#getsnapshotbeforeupdate) está sendo adicionado para oferecer suporte para leitura segura das propriedades, por exemplo, do DOM, antes que as atualizações sejam feitas.

[Saiba mais sobre essas mudanças no ciclo de vida aqui.](/blog/2018/03/27/update-on-async-rendering.html)

## `StrictMode` Component {#strictmode-component}

`StrictMode` is a tool for highlighting potential problems in an application. Like `Fragment`, `StrictMode` does not render any visible UI. It activates additional checks and warnings for its descendants.

> **Note:**
>
> `StrictMode` checks are run in development mode only; _they do not impact the production build_.

Although it is not possible for strict mode to catch all problems (e.g. certain types of mutation), it can help with many. If you see warnings in strict mode, those things will likely cause bugs for async rendering.

In version 16.3, `StrictMode` helps with:
* Identifying components with unsafe lifecycles
* Warning about legacy string ref API usage
* Detecting unexpected side effects

Additional functionality will be added with future releases of React.

[Learn more about the `StrictMode` component here.](/docs/strict-mode.html)
