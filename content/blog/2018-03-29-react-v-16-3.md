---
title: "React v16.3.0: Novos ciclos de vida e API de contexto"
author: [bvaughn]
---

Há alguns dias, [escrevemos uma postagem sobre as próximas mudanças em nossos métodos de ciclo de vida herdados](/blog/2018/03/27/update-on-async-rendering.html), incluindo estratégias de migração gradual. No React 16.3.0, estamos adicionando alguns novos métodos de ciclo de vida para ajudar nessa migração. Também estamos introduzindo novas APIs para longas características solicitadas: uma API de contexto oficial, uma API de encaminhamento de referência e uma API de referência ergonômica.

Leia para saber mais sobre o lançamento.

## API de Contexto Oficial {#official-context-api}

Por muitos anos, o React ofereceu uma API experimental para contexto. Embora fosse uma ferramenta poderosa, seu uso foi desencorajado por causa de problemas inerentes na API, e porque sempre pretendíamos substituir a API experimental por uma melhor.

A versão 16.3 introduz uma nova API de contexto que é mais eficiente e suporta tanto verificação de tipo estático quanto atualizações profundas.

> **Nota**
>
> A antiga API de contexto continuará funcionando para todas as versões do React 16.x, assim você terá tempo para migrar.

Aqui está um exemplo ilustrando como você pode introduzir um “tema” usando a nova API de contexto:
`embed:16-3-release-blog-post/context-example.js`

[Saiba mais sobre a nova API de contexto aqui.](/docs/context.html)

## API `createRef` {#createref-api}

Anteriormente, o React fornecia duas maneiras de gerenciar refs: a API de string ref e a API de callback. Embora a API de string ref ter sido a mais conveniente das duas, ela tinha [várias desvantagens](https://github.com/facebook/react/issues/1373) e assim nossa recomendação oficial era usar o formulário de callback.

A versão 16.3 adiciona uma nova opção para gerenciar refs que oferecem o conforto de uma string ref sem nenhuma das desvantagens:
`embed:16-3-release-blog-post/create-ref-example.js`

> **Nota:**
>
> As callback refs continuarão sendo suportadas, além da nova API `createRef`.
>
> Você não precisa substituir as callback refs em seus componentes. Elas são um pouco mais flexíveis, portanto, elas permanecerão como um recurso avançado.

[Saiba mais sobre a nova API `createRef` aqui.](/docs/refs-and-the-dom.html)

## API `forwardRef` {#forwardref-api}

Geralmente, os componentes React são declarativos, mas às vezes é necessário o acesso imperativo às instâncias do componente e aos nós DOM subjacentes. Isso é comum em casos de uso, como gerenciamento de foco, seleção ou animações. O React fornece [refs](/docs/refs-and-the-dom.html) como uma forma de resolver este problema. No entanto, o encapsulamento de componentes apresenta alguns desafios com as refs.

Por exemplo, se você trocar um `<button>` por um componente `<FancyButton>`, o atributo `ref` nele começará apontando para o componente wrapper em vez do nó DOM (e seria `null` para componentes funcionais). Embora isso seja desejável para componentes de "nível de aplicação" como `FeedStory` ou `Comment` que precisam ser encapsulados, isso pode ser irritante para componentes "folha" como `FancyButton` ou `MyTextInput` que são tipicamente usados como seus homólogos DOM, e podem precisar expor seus nós DOM.

O encaminhamento de referência é um novo recurso de inclusão que permite que alguns componentes `ref` sejam recebidos, e passem para baixo (em outras palavras, "encaminhá-lo") para um filho. No exemplo abaixo, `FancyButton` encaminha seu ref para um DOM `button` que renderiza:

`embed:16-3-release-blog-post/fancy-button-example.js`

Dessa forma, os componentes que usam `FancyButton` podem obter uma ref ao nó do DOM do `button` subjacente e acessá-lo se necessário—assim como se usassem um `button` DOM diretamente.

O encaminhamento de ref não está limitado para componentes de "folha" que rederizam nós do DOM. Se você escreve [componente de alta-ordem](/docs/higher-order-components.html), recomendamos o uso do encaminhamento de referência para passar automaticamente as ref para as instâncias do componente de classe wrapper.

[Saiba mais sobre a API forwardRef aqui.](/docs/forwarding-refs.html)

## Component Lifecycle Changes {#component-lifecycle-changes}

React's class component API has been around for years with little change. However, as we add support for more advanced features (such as [error boundaries](/docs/react-component.html#componentdidcatch) and the upcoming [async rendering mode](/blog/2018/03/01/sneak-peek-beyond-react-16.html)) we stretch this model in ways that it was not originally intended.

For example, with the current API, it is too easy to block the initial render with non-essential logic. In part this is because there are too many ways to accomplish a given task, and it can be unclear which is best. We've observed that the interrupting behavior of error handling is often not taken into consideration and can result in memory leaks (something that will also impact the upcoming async rendering mode). The current class component API also complicates other efforts, like our work on [prototyping a React compiler](https://twitter.com/trueadm/status/944908776896978946).

Many of these issues are exacerbated by a subset of the component lifecycles (`componentWillMount`, `componentWillReceiveProps`, and `componentWillUpdate`). These also happen to be the lifecycles that cause the most confusion within the React community. For these reasons, we are going to deprecate those methods in favor of better alternatives.

We recognize that this change will impact many existing components. Because of this, the migration path will be as gradual as possible, and will provide escape hatches. (At Facebook, we maintain more than 50,000 React components. We depend on a gradual release cycle too!)

> **Note:**
>
> Deprecation warnings will be enabled with a future 16.x release, **but the legacy lifecycles will continue to work until version 17**.
>
> Even in version 17, it will still be possible to use them, but they will be aliased with an "UNSAFE_" prefix to indicate that they might cause issues. We have also prepared an [automated script to rename them](https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles) in existing code.

In addition to deprecating unsafe lifecycles, we are also adding a couple of new lifecyles:
* [`getDerivedStateFromProps`](/docs/react-component.html#static-getderivedstatefromprops) is being added as a safer alternative to the legacy `componentWillReceiveProps`. (Note that [in most cases you don't need either of them](/blog/2018/06/07/you-probably-dont-need-derived-state.html).)
* [`getSnapshotBeforeUpdate`](/docs/react-component.html#getsnapshotbeforeupdate) is being added to support safely reading properties from e.g. the DOM before updates are made.

[Learn more about these lifecycle changes here.](/blog/2018/03/27/update-on-async-rendering.html)

## `StrictMode` Component {#strictmode-component}

`StrictMode` is a tool for highlighting potential problems in an application. Like `Fragment`, `StrictMode` does not render any visible UI. It activates additional checks and warnings for its descendants.

> **Note:**
>
> `StrictMode` checks are run in development mode only; _they do not impact the production build_.

Although it is not possible for strict mode to catch all problems (e.g. certain types of mutation), it can help with many. If you see warnings in strict mode, those things will likely cause bugs for async rendering.

In version 16.3, `StrictMode` helps with:
* Identifying components with unsafe lifecycles
* Warning about legacy string ref API usage
* Detecting unexpected side effects

Additional functionality will be added with future releases of React.

[Learn more about the `StrictMode` component here.](/docs/strict-mode.html)
